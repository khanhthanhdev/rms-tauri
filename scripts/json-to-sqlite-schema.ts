#!/usr/bin/env bun
/**
 * Extracts schema from a JSON file (like 1234.db.json) and generates SQLite CREATE TABLE statements.
 * Infers field types from JSON values: number -> INTEGER, string -> TEXT, object/array -> TEXT (JSON).
 *
 * Usage: bun run scripts/json-to-sqlite-schema.ts [path/to/file.json] [--out schema.sql]
 */

const args = process.argv.slice(2);
const inputPath = args.find((a) => !a.startsWith("--")) ?? "1234.db.json";
const outIdx = args.indexOf("--out");
const outputPath = outIdx >= 0 ? args[outIdx + 1] : null;

function toSnakeCase(s: string): string {
  // Insert underscore before capitals, handle acronyms (ID, FMS, etc.)
  return s
    .replace(/([a-z])([A-Z])/g, "$1_$2")
    .replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2")
    .toLowerCase()
    .replace(/[^a-z0-9_]+/g, "_")
    .replace(/^_|_$/g, "");
}

function inferSqliteType(values: unknown[]): {
  type: string;
  nullable: boolean;
} {
  const nonNull = values.filter((v) => v !== null && v !== undefined);
  const nullable = values.some((v) => v === null || v === undefined);

  if (nonNull.length === 0) {
    return { type: "TEXT", nullable: true };
  }

  const types = new Set(nonNull.map((v) => typeof v));

  if (types.has("object") || types.has("boolean")) {
    return { type: "TEXT", nullable };
  }
  if (types.has("number")) {
    const nums = nonNull.filter((v): v is number => typeof v === "number");
    const hasFloat = nums.some((n) => Number.isFinite(n) && n % 1 !== 0);
    return { type: hasFloat ? "REAL" : "INTEGER", nullable };
  }
  if (types.has("string")) {
    return { type: "TEXT", nullable };
  }
  return { type: "TEXT", nullable };
}

function collectFields(rows: unknown[]): Map<string, unknown[]> {
  const fields = new Map<string, unknown[]>();
  for (const row of rows) {
    if (row && typeof row === "object" && !Array.isArray(row)) {
      for (const [k, v] of Object.entries(row)) {
        const arr = fields.get(k) ?? [];
        if (!fields.has(k)) {
          fields.set(k, arr);
        }
        arr.push(v);
      }
    }
  }
  return fields;
}

async function main() {
  const content = await import("node:fs/promises").then((fs) =>
    fs.readFile(inputPath, "utf-8")
  );
  const data = JSON.parse(content) as Record<string, unknown>;

  const tables: string[] = [];
  for (const [key, value] of Object.entries(data)) {
    if (!Array.isArray(value) || value.length === 0) {
      continue;
    }

    const tableName = toSnakeCase(key);
    const fields = collectFields(value);

    const columns: string[] = [];
    for (const [fieldName, values] of fields) {
      const colName = toSnakeCase(fieldName);
      const { type, nullable } = inferSqliteType(values);
      const nullStr = nullable ? "" : " NOT NULL";
      columns.push(`  ${colName} ${type}${nullStr}`);
    }

    const createSql = `CREATE TABLE IF NOT EXISTS ${tableName} (\n${columns.join(",\n")}\n);`;
    tables.push(`-- ${key}\n${createSql}`);
  }

  const output = [
    `-- SQLite schema extracted from ${inputPath}`,
    "-- Generated by scripts/json-to-sqlite-schema.ts",
    "",
    tables.join("\n\n"),
  ].join("\n");

  if (outputPath) {
    await import("node:fs/promises").then((fs) =>
      fs.writeFile(outputPath, output)
    );
    console.log(`Schema written to ${outputPath}`);
  } else {
    console.log(output);
  }
}

main().catch(console.error);
